from uuid import uuid4
from layers.layer import Layer


class DagException(Exception):
    def __init__(self, *args: object):
        super().__init__(*args)


class DagNode:
    def __init__(self, layer: Layer):
        self.id = uuid4()
        self.layer = layer
        self.seen = False


class DirectedAcyclicGraph:
    def __init__(self):
        self.nodes: list[DagNode]
        self.edges: list[tuple[DagNode, DagNode]]
        self.inputs: list[DagNode]


    def _unsee(self):
        for n in self.nodes:
            n.seen = False


    def _get_head_nodes(self) -> list[DagNode]:
        for e in self.edges:
            e[1].seen = True
        head_nodes = [n for n in self.nodes if not n.seen]
        self._unsee()
        return head_nodes


    def _is_acyclic(self) -> bool:
        if len(self.edges) < 2:
            return True
        for head in self._get_head_nodes():
            head.seen = True
            if not self._is_acyclic(head):
                head.seen = False
                return False
            head.seen = False
        return True

    
    def _is_acyclic(self, node: DagNode) -> bool:
        for n in self._get_downstream_nodes(node):
            if n.seen:
                return False
            n.seen = True
            if not self._is_acyclic(n):
                n.seen = False
                return False
            n.seen = False
        return True


    def _get_downstream_nodes(self, node: DagNode) -> list[DagNode]:
        return [e[1] for e in self.edges if e[0] == node]


    def _get_upstream_nodes(self, node: DagNode) -> list[DagNode]:
        return [e[0] for e in self.edges if e[1] == node]


    def connect_nodes(self, source_node, dest_node):
        if (source_node, dest_node) in self.edges:
            raise DagException("Connection already exists")
        else:
            self.edges.append((source_node, dest_node))
            if not self._is_acyclic():
                self.edges.pop()
                raise DagException("Circular graphs not allowed")


    def disconnect_nodes(self, source_node, dest_node):
        if (source_node, dest_node) in self.edges:
            self.edges.remove((source_node, dest_node))


    def add_node(self, layer: Layer) -> DagNode:
        node = DagNode(layer)
        if not node in self.nodes:
            if layer.type == 'input':
                self.inputs.append(node)
            self.nodes.append(node)
            return node
        else:
            raise DagException("Node already added")


    def remove_node(self, node: DagNode):
        for e in list(self.edges):
            if node in e:
                self.edges.remove(e)
        self.nodes.remove(node)


    def construct_keras(self):
        if not self.edges:
            raise DagException("The graph has no connections")

        model_file = "##~ Model code generated by MAI: DO NOT TOUCH! ~Mai\n\n"

        for head in self._get_head_nodes():
            head.seen = True
            model_file += head.layer.generate_code_line() + '\n'
            model_file += self._construct_keras(head)

        self._unsee()
        return model_file


    def _construct_keras(self, node: DagNode):
        model_file = ''
        for n in self._get_downstream_nodes(node):
            upstream_loaded = True
            for upstream_node in self._get_upstream_nodes(n):
                if not upstream_node.seen:
                    upstream_loaded = False
            if upstream_loaded:
                n.seen = True
                model_file += n.layer.generate_code_line() + '\n'
                model_file += self._construct_keras(n)

        return model_file + '\n'


